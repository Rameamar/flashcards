Who formalized the algorithm concept?	Church and Turing in 1930s
Features of an equivalence relation?	Reflexive, Symmetric and Transitive.
What are "connected components" in the dynamic connectivity context?	Maximal set of objects that are mutually connected.
In general terms, how is implemented the find operation in Union-Find algorithms?	Checking if the two objects are in the same connected component.
In general terms, how is implemented the union operation in Union-Find algorithms?	Replacing connected components containing two objects with their union.
<div>How many connected components result after performing the following sequence of union operations on a set of 10 items?&nbsp;</div><div><br /></div><div>1-2 &nbsp;3-4 &nbsp;5-6 &nbsp;7-8 &nbsp;7-9 &nbsp;2-8 &nbsp;0-5 &nbsp;1-9</div>	3
What's the eager algorithm to solve the dynamic connectivity problem?	Quick-find.
What's the data structure that support the Quick-find algorithm?	An integer array indexed by objects whose values are the connected component identifiers. That array is initialized with the same values than the objects.
How the quick-find algorithm implements the find query?	Checks whether the value of the two objects in the ID array is the same, i.e. if they are in the same connected component.
How is implemented the union command by the quick-find algorithm?	Change all entries with id[p] to id[q].
Number of array accesses for each of the operations of the quick-find algorithm	Initialize: N<div>Find: 2</div><div>Union: 2N + 2</div>
What's the defect of quick-find	Union is too expensive. Takes N<sup>2</sup>&nbsp;(quadratic) array accesses to process sequence of N union commands on N objects.
<div>What is the maximum number of id[] array entries that can change during one call to union when using the quick-find data structure on N elements?</div>	N - 1
What's the problem with quadratic algorithms?	Quadratic algorithms don't scale with technology. New computers may be 10x as fast, but also has 10x much memory, so with quadratic algorithm, the computations take 10x longer.
What's the lazy approach to implement Union-Find?	Quick-union algorithm.
What's the data structure used by the Quick-union algorithm?	Integer array id[] of size N. The id[i] value represents the i-th node's parent.
<div>Suppose that in a quick-union data structure on 10 elements that the id[] array is</div><div><br /></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 9 6 5 4 2 6 1 0 5</div><div><br /></div><div>What are the roots of 3 and 7, respectively?</div><div><br /></div>	6 and 6.
How the find operation is implemented by the Quick-union algorithm?	Check if p and q have the same root.
How is implemented the union command by the Quick-union algorithm?	To merge components containing p and q, set the id of p's root to the id of q's root.
What's the defect of Quick-union algorithm?	Trees can get tall, so find command is too expensive (could be N array access).
<div>What is the maximum number of array accesses during a find operation when using the quick-union data structure on N elements?</div>	Linear.
Describe the weighted quick-union improvement	Modify quick-union to avoid tall trees.<div>Keep track of size of each tree.</div><div>Balance by linking root of smaller tree to root of larger tree.</div>
What's the data structure to implement weighted quick-union?	The same as quick-union, but maintain an extra array sz[] to count the number of objects in the tree rooted at i.
Running time for union and find operations in Weighted Quick Union	Find: takes time proportional to depth of p and q.<div>Union: Takes constant time, given roots.</div>
What's the depth of node x in Weighted Quick-union?	At most Lg N.
Describe the proof for the proposition:&nbsp;"Depth of any node x is at most Lg N"	When does depth of x increase?<div><br /></div><div>Increases by 1 when tree T<sub>1</sub>&nbsp;containing x is merge with another tree T<sub>2.</sub></div><div><sub><br /></sub></div><div>The size of the merged tree containing x at least doubles since the size of T<sub>2</sub>&nbsp;is greater of equals to size of T<sub>1</sub>.</div><div><br /></div><div>The size of the tree containing x can double at most Log N times.</div>
What's the cost of operations in Weighted Quick-union?	Initialize: N<div>Union: Lg N (including cost of finding roots).</div><div>Find: Lg N</div>
Describe the approach behind the Quick-union with Path Compression improvement.	When we are trying to find the root of the tree containing a given node, we are touching all the nodes on the path from that node to the root. While we are doing that we might as well make each of those nodes just point to the root.
Enum two implementations for the QUPC algorithm	Two-pass implementation: Add a second loop to the root() method to set the id[] of each examined node to the root.<div>Simple one-pass variant: Make every other node in path point to its grandparent (thereby halving path length).</div>
Describe "Proposition of Hopcroft-Ulman, Tarjan" about the WQUPC algorithm.	Starting with an empty data structure, any sequence of M union-find ops on N objects make &lt;= c(N + M Lg* &nbsp;N) array acceses.<div><br /></div><div>Lg* &nbsp;N &nbsp;= Iterate log function =&gt; the number of times you have to take the Lg of N to get 1.</div><div><br /></div><div>In the real world you can think of that as a number less than 5, because Lg* 2<sup>65536</sup>&nbsp;= 5.<br /><div><br /></div><div>Analysis can be improved to <img src="latex-fff8d689ed8bc8b7cafc1bc95b19c5452ec5abbf.png">, where [$]\alpha[\$] is the Ackermann function that grows even more slowly than Lg*.</div></div>
Is WQUPC a linear-time algorithm?	In theory, WQUPC is not linear-time.<div>In practice, WQUPC is linear.</div>
Is there a linear-time algorithm for the union find problem?	Friedman and Sachs proved that there is not such algorithm.
What are the worst-case time for M union-find ops on a set of N objects in each of the QU algorithms?	Quick-find: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;M N<div>Quick-union: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;M N</div><div>Weighted QU: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;N + M &nbsp;Lg N</div><div>QU + path compression: &nbsp; &nbsp; N + M &nbsp;Lg N</div><div>WQUPC: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; N + M &nbsp;Lg* N</div>
<div>Suppose that the id[] array during the weighted quick union algorithm is</div><div><br /></div><div>&nbsp; &nbsp; 0 0 0 0 0 0 7 8 8 8</div><div><br /></div><div>Which id[] entry changes when we apply the union operation to 3 and 6?&nbsp;</div>	id[8]
Definition of percolation	A model for many physical systems consisting in a N-by-N grid of "sites". Each site is open with a probability p (or blocked with probability 1-p).<div><br /></div><div>System percolates if top and bottom are connected by open sites.</div>
What is the definition of the "percolation probability"?	When N (number of sites) is large, theory guarantees a sharp threshold p* where:<div><br /></div><div>p &gt; p*: almost certainly percolates.</div><div>p &lt; p*: almost certainly does not percolate.</div><div><br /></div>
How do you find the solution to the mathematical problem of percolation probability?	Nobody knows the solution to that mathematical problem.&nbsp;<div><br /></div><div>The only solution we have comes from a computational model, where we run simulations to try to determine the value of that probability. Those simulations are only enable by fast union find algorithms.</div>
<div>When opening one new site in the percolation simulation, how many times is union() called?</div>	0, 1, 2, 3 or 4 times.
How many times is called the find operation in the percolation connectivity model?	Only once, because we introduce 2 virtual sites (and connections to top and bottom sites), so the system percolates if virtual top site is connected with the virtual bottom one.<div><br /></div><div>This way we avoid the brute-force algorithm (N<sup>2 </sup>calls to find) consisting of checking if any site on bottom row is connected to a site on top row.</div>
