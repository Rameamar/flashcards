Who formalized the algorithm concept?	Church and Turing in 1930s
Features of an equivalence relation?	Reflexive, Symmetric and Transitive.
What are "connected components" in the dynamic connectivity context?	Maximal set of objects that are mutually connected.
In general terms, how is implemented the find operation in Union-Find algorithms?	Checking if the two objects are in the same connected component.
In general terms, how is implemented the union operation in Union-Find algorithms?	Replacing connected components containing two objects with their union.
<div>How many connected components result after performing the following sequence of union operations on a set of 10 items?&nbsp;</div><div><br /></div><div>1-2 &nbsp;3-4 &nbsp;5-6 &nbsp;7-8 &nbsp;7-9 &nbsp;2-8 &nbsp;0-5 &nbsp;1-9</div>	3
What's the eager algorithm to solve the dynamic connectivity problem?	Quick-find.
What's the data structure that support the Quick-find algorithm?	An integer array indexed by objects whose values are the connected component identifiers. That array is initialized with the same values than the objects.
How the quick-find algorithm implements the find query?	Checks whether the value of the two objects in the ID array is the same, i.e. if they are in the same connected component.
How is implemented the union command by the quick-find algorithm?	Change all entries with id[p] to id[q].
Number of array accesses for each of the operations of the quick-find algorithm	Initialize: N<div>Find: 2</div><div>Union: 2N + 2</div>
What's the defect of quick-find	Union is too expensive. Takes N<sup>2</sup>&nbsp;(quadratic) array accesses to process sequence of N union commands on N objects.
<div>What is the maximum number of id[] array entries that can change during one call to union when using the quick-find data structure on N elements?</div>	N - 1
What's the problem with quadratic algorithms?	Quadratic algorithms don't scale with technology. New computers may be 10x as fast, but also has 10x much memory, so with quadratic algorithm, the computations take 10x longer.
What's the lazy approach to implement Union-Find?	Quick-union algorithm.
What's the data structure used by the Quick-union algorithm?	Integer array id[] of size N. The id[i] value represents the i-th node's parent.
<div>Suppose that in a quick-union data structure on 10 elements that the id[] array is</div><div><br /></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 9 6 5 4 2 6 1 0 5</div><div><br /></div><div>What are the roots of 3 and 7, respectively?</div><div><br /></div>	6 and 6.
How the find operation is implemented by the Quick-union algorithm?	Check if p and q have the same root.
How is implemented the union command by the Quick-union algorithm?	To merge components containing p and q, set the id of p's root to the id of q's root.
What's the defect of Quick-union algorithm?	Trees can get tall, so find command is too expensive (could be N array access).
<div>What is the maximum number of array accesses during a find operation when using the quick-union data structure on N elements?</div>	Linear.
Describe the weighted quick-union improvement	Modify quick-union to avoid tall trees.<div>Keep track of size of each tree.</div><div>Balance by linking root of smaller tree to root of larger tree.</div>
What's the data structure to implement weighted quick-union?	The same as quick-union, but maintain an extra array sz[] to count the number of objects in the tree rooted at i.
Running time for union and find operations in Weighted Quick Union	Find: takes time proportional to depth of p and q.<div>Union: Takes constant time, given roots.</div>
What's the depth of node x in Weighted Quick-union?	At most Lg N.
Describe the proof for the proposition:&nbsp;"Depth of any node x is at most Lg N"	When does depth of x increase?<div><br /></div><div>Increases by 1 when tree T<sub>1</sub>&nbsp;containing x is merge with another tree T<sub>2.</sub></div><div><sub><br /></sub></div><div>The size of the merged tree containing x at least doubles since the size of T<sub>2</sub>&nbsp;is greater of equals to size of T<sub>1</sub>.</div><div><br /></div><div>The size of the tree containing x can double at most Log N times.</div>
What's the cost of operations in Weighted Quick-union?	Initialize: N<div>Union: Lg N (including cost of finding roots).</div><div>Find: Lg N</div>
Describe the approach behind the Quick-union with Path Compression improvement.	When we are trying to find the root of the tree containing a given node, we are touching all the nodes on the path from that node to the root. While we are doing that we might as well make each of those nodes just point to the root.
Enum two implementations for the QUPC algorithm	Two-pass implementation: Add a second loop to the root() method to set the id[] of each examined node to the root.<div>Simple one-pass variant: Make every other node in path point to its grandparent (thereby halving path length).</div>
Describe "Proposition of Hopcroft-Ulman, Tarjan" about the WQUPC algorithm.	Starting with an empty data structure, any sequence of M union-find ops on N objects make &lt;= c(N + M Lg* &nbsp;N) array acceses.<div><br /></div><div>Lg* &nbsp;N &nbsp;= Iterate log function =&gt; the number of times you have to take the Lg of N to get 1.</div><div><br /></div><div>In the real world you can think of that as a number less than 5, because Lg* 2<sup>65536</sup>&nbsp;= 5.<br /><div><br /></div><div>Analysis can be improved to <img src="latex-fff8d689ed8bc8b7cafc1bc95b19c5452ec5abbf.png">, where [$]\alpha[\$] is the Ackermann function that grows even more slowly than Lg*.</div></div>
Is WQUPC a linear-time algorithm?	In theory, WQUPC is not linear-time.<div>In practice, WQUPC is linear.</div>
Is there a linear-time algorithm for the union find problem?	Friedman and Sachs proved that there is not such algorithm.
What are the worst-case time for M union-find ops on a set of N objects in each of the QU algorithms?	Quick-find: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;M N<div>Quick-union: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;M N</div><div>Weighted QU: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;N + M &nbsp;Lg N</div><div>QU + path compression: &nbsp; &nbsp; N + M &nbsp;Lg N</div><div>WQUPC: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; N + M &nbsp;Lg* N</div>
<div>Suppose that the id[] array during the weighted quick union algorithm is</div><div><br /></div><div>&nbsp; &nbsp; 0 0 0 0 0 0 7 8 8 8</div><div><br /></div><div>Which id[] entry changes when we apply the union operation to 3 and 6?&nbsp;</div>	id[8]
Definition of percolation	A model for many physical systems consisting in a N-by-N grid of "sites". Each site is open with a probability p (or blocked with probability 1-p).<div><br /></div><div>System percolates if top and bottom are connected by open sites.</div>
What is the definition of the "percolation probability"?	When N (number of sites) is large, theory guarantees a sharp threshold p* where:<div><br /></div><div>p &gt; p*: almost certainly percolates.</div><div>p &lt; p*: almost certainly does not percolate.</div><div><br /></div>
How do you find the solution to the mathematical problem of percolation probability?	Nobody knows the solution to that mathematical problem.&nbsp;<div><br /></div><div>The only solution we have comes from a computational model, where we run simulations to try to determine the value of that probability. Those simulations are only enable by fast union find algorithms.</div>
<div>When opening one new site in the percolation simulation, how many times is union() called?</div>	0, 1, 2, 3 or 4 times.
How many times is called the find operation in the percolation connectivity model?	Only once, because we introduce 2 virtual sites (and connections to top and bottom sites), so the system percolates if virtual top site is connected with the virtual bottom one.<div><br /></div><div>This way we avoid the brute-force algorithm (N<sup>2 </sup>calls to find) consisting of checking if any site on bottom row is connected to a site on top row.</div>
Proof that if the T(N) vs N is a straight line in a log-log scale then T(N) follows the power law.	If log(T(N)) = b log(N) + c &nbsp; &nbsp; &nbsp;<div><br /></div><div>;then if you raise both sides to 2: &nbsp;</div><div><br /></div><div>T(N) = &nbsp;a N <sup>b</sup>&nbsp; &nbsp;</div><div><br /></div><div>; where b is the slope of the straight in log-log plot.</div><div>&nbsp; a = 2<sup>c</sup></div>
How to estimate b in a power-law relationship?	Using the doubling hypothesis:<div><br /></div><div>Run the program doubling the size of the input, then b = lg ratio &nbsp;where ratio is the ration between the times for each of the input sizes.</div>
How to estimate a in a power-law relationship (assuming you know b)?	Run the program (for a sufficient large value of N) and solve for a.
Which kind of effects determine the exponent b and the constant a in power-law relationship?	System independent effects:<div>* Algorithm.</div><div>* Input data.</div><div><br /></div><div><br /></div><div><span style=" font-style: normal; font-weight: normal;">System dependent effects:</span></div><div><span style=" font-style: normal; font-weight: normal;">* Hardware: CPU, memory, cache...</span></div><div><span style=" font-style: normal; font-weight: normal;">* Software: compiler, interpreter, garbage collector...</span></div><div><span style=" font-style: normal; font-weight: normal;">* System: operating system, network, other apps...</span></div><div><span style=" font-style: normal; font-weight: normal;"><br /></span></div><div><span style=" font-style: normal; font-weight: normal;"><br /></span></div><div>System independent effects determines the exponent b.</div><div>Both, system independent and system dependent effects determine the constant a.</div><div><br /></div>
What is the cost model simplification to calculate running time?	Consist of use some basic operations as a proxy for running time.
What is the tilde notation simplification to estimate running time?	Consist of ignoring lower order terms:<div>* when N is large, terms are negligible.</div><div>* when N is small, we don't care.</div>
How can you estimate a discrete sum?	Replacing the sum with an integral and using calculus.
Describe the common order-of-growth classification	<div>order-of-growth &nbsp; &nbsp;name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typical code &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; description &nbsp; &nbsp; &nbsp; &nbsp; example &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; T(2N)/T(N)</div><div>&nbsp;</div><div>1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;constant &nbsp; &nbsp; &nbsp; &nbsp;a = b + c; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;statement &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; add two numbers &nbsp; &nbsp; &nbsp; &nbsp;1</div><div><br /></div><div>log N &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;logarithmic &nbsp; &nbsp; while (N &gt; 1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;divide in half &nbsp; &nbsp; &nbsp; binary search &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;~ 1</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { N = N / 2; ... }</div><div><br /></div><div>N &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;linear &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; N; i++) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loop &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;find the maximum &nbsp; &nbsp; &nbsp; &nbsp;2</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ ... }</div><div><br /></div><div>N log N &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; linearithmic &nbsp; &nbsp; mergesort &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;divide&nbsp;and &nbsp; &nbsp; &nbsp; &nbsp; mergesort &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ~ 2 &nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conquer</div><div><br /></div><div>N<sup>2</sup>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; quadratic &nbsp; &nbsp; &nbsp; &nbsp;for (int i = 0; i &lt; N; i++) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; double loop &nbsp; &nbsp; &nbsp; check all pairs &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (int j = 0; j &lt; N; j++)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ ... }</div><div><br /></div><div>N<sup>3</sup>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qubic &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; N; i++) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; triple loop &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;check all triples &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (int j = 0; j &lt; N; j++)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (int k = 0; k &lt; N; k++)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ ... }</div><div><br /></div><div>2<sup>N</sup>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;exponential &nbsp; &nbsp; &nbsp; &nbsp; combinatorial search &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;exhaustive search &nbsp; check all subsets &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T(N)</div>
What kind of algorithms you need to keep the pace of Moore's Law?	Linear or linearithmic (or best).
Describe an improved algorithm to solve the 3-sum problem	Sorting-based algorithm for 3-sum:<div><br /></div><div>* Sort the N numbers.</div><div>* For each pair of numbers a[i] and a[j] binary search for -(a[i] + a[j]).</div><div><br /></div><div>The order of growth of this algorithm will be N<sup>2 </sup>Lg N which is much better than the N<sup>3</sup>&nbsp;of the brute force algorithm.</div>
Which types of analyses of algorithms exists?	Best case: lower bound in cost.<div>Worst case: upper bound in cost.</div><div>Average case: expected cost.</div>
Describe the commonly used notations in theory of algorithms	- Big Theta notation: asymptotic order of growth. Used to classify algorithms.<div>- Big Oh notation: Upper bounds.</div><div>- Big Omega notation: Lower bounds.</div>
Big-Oh notation can be interpreted as an approximate model?	No, it's a common mistake. To provide approximate models you must use the tilde notation. Big-Oh notation provides upper bounds.
What are the memory usage for Java primitive types?	boolean &nbsp;1 byte<div>byte &nbsp; &nbsp; &nbsp; 1 byte</div><div>char &nbsp; &nbsp; &nbsp; 2 bytes</div><div>int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 bytes</div><div>float &nbsp; &nbsp; &nbsp; 4 bytes</div><div>long &nbsp; &nbsp; &nbsp; 8 bytes</div><div>double &nbsp; 8 bytes</div>
What is the memory overhead of arrays in Java?	24 bytes.<div><br /></div><div>Ex:</div><div>char[] &nbsp; &nbsp; &nbsp;2N + 24</div><div>int[] &nbsp; &nbsp; &nbsp; &nbsp; 4N + 24</div><div>double[] &nbsp; 8N + 24</div>
What is the typical memory usage of Java objects?	Object overhead: 16 bytes<div>Reference: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8 bytes</div><div>Padding: &nbsp;each object use a multiple of 8 bytes.</div><div><br /></div><div>Ex:</div><div><br /></div><div>Date {</div><div>&nbsp; int day</div><div>&nbsp; int month</div><div>&nbsp; int year</div><div>}</div><div><br /></div><div>uses 32 bytes of memory =&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp;16 bytes object overhead</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 bytes day</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 bytes month</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 bytes year</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 bytes padding</div>
What's the memory usage of a Java String object?	<br /><div>public class String {</div><div>&nbsp; private char[] value;</div><div>&nbsp; private int offset;</div><div>&nbsp; private int count;</div><div>&nbsp; private int hash;</div><div>}</div><div><br /></div><div>object overhead = 16 bytes</div><div>value = &nbsp; 8 bytes reference</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2N + 24 &nbsp;(char[])</div><div>offset = 4 bytes</div><div>count = 4 bytes</div><div>hash = 4 bytes</div><div>padding = 4 bytes</div><div><br /></div><div>2N + 64 ~ 2N</div>
<div>Give the id[] array that results from the following sequence of 6 union</div><div>operations on a set of 10 items using the quick-find algorithm.</div><div><br /></div><div>&nbsp; &nbsp; 5-4 9-0 5-3 7-0 7-1 1-2&nbsp;</div><div><br /></div><div>Recall: our quick-find convention for the union operation p-q is to change id[p]&nbsp;(and perhaps some other entries) but not id[q].</div>	<div>The correct answer is:2 2 2 3 3 3 6 2 8 2</div><div><br /></div><div>Here is the id[] array after each union operation:</div><div><br /></div><div>&nbsp; &nbsp; &nbsp; 0 1 2 3 4 5 6 7 8 9&nbsp;</div><div>5-4: &nbsp;0 1 2 3 4 4 6 7 8 9&nbsp;</div><div>9-0: &nbsp;0 1 2 3 4 4 6 7 8 0&nbsp;</div><div>5-3: &nbsp;0 1 2 3 3 3 6 7 8 0&nbsp;</div><div>7-0: &nbsp;0 1 2 3 3 3 6 0 8 0&nbsp;</div><div>7-1: &nbsp;1 1 2 3 3 3 6 1 8 1&nbsp;</div><div>1-2: &nbsp;2 2 2 3 3 3 6 2 8 2&nbsp;</div>
<div>Give the id[] array that results from the following sequence of 9 union</div><div>operations on a set of 10 items using the weighted quick-union algorithm from lecture.</div><div><br /></div><div>&nbsp; &nbsp; 8-5 7-2 2-3 9-3 4-0 4-5 1-3 4-7 9-6&nbsp;</div><div><br /></div><div>Recall: when joining two trees of equal size, our weighted quick union convention&nbsp;is to make the root of the second tree point to the root of the first tree.</div>	<div>The correct answer is:4 7 7 7 7 8 7 7 4 7</div><div><br /></div><div>Here is the id[] array after each union operation:</div><div><br /></div><div>&nbsp; &nbsp; &nbsp; 0 1 2 3 4 5 6 7 8 9&nbsp;</div><div>8-5: &nbsp;0 1 2 3 4 8 6 7 8 9&nbsp;</div><div>7-2: &nbsp;0 1 7 3 4 8 6 7 8 9&nbsp;</div><div>2-3: &nbsp;0 1 7 7 4 8 6 7 8 9&nbsp;</div><div>9-3: &nbsp;0 1 7 7 4 8 6 7 8 7&nbsp;</div><div>4-0: &nbsp;4 1 7 7 4 8 6 7 8 7&nbsp;</div><div>4-5: &nbsp;4 1 7 7 4 8 6 7 4 7&nbsp;</div><div>1-3: &nbsp;4 7 7 7 4 8 6 7 4 7&nbsp;</div><div>4-7: &nbsp;4 7 7 7 7 8 6 7 4 7&nbsp;</div><div>9-6: &nbsp;4 7 7 7 7 8 7 7 4 7&nbsp;</div>
<div>Which of the following id[] array(s) could be the result of running the weighted quick union</div><div>algorithm on a set of 10 items?</div><div><div><br /></div><div>0 1 6 3 4 5 6 1 6 9</div><div>3 3 3 3 9 0 3 8 9 3</div><div>9 0 8 2 7 8 9 8 1 8</div><div>1 1 5 6 4 0 5 6 5 5</div><div>9 8 8 3 6 3 5 9 3 8</div></div>	<div>0 1 6 3 4 5 6 1 6 9 : 6-8 1-7 2-8&nbsp;</div><div>3 3 3 3 9 0 3 8 9 3 : 3-1 8-7 0-5 1-2 9-4 9-8 6-3 6-5 0-8&nbsp;</div><div>9 0 8 2 7 8 9 8 1 8 : The id[] array contains a cycle: 1-&gt;0-&gt;9-&gt;8-&gt;1</div><div>1 1 5 6 4 0 5 6 5 5 : Height of forest = 4 &gt; lg N = lg(10)</div><div>9 8 8 3 6 3 5 9 3 8 : Size of tree rooted at parent of 8 &lt; twice the size of tree rooted at 8</div>
<div>Given the following definition of a MysteryBox object:&nbsp;</div><div><br /></div><div>public class MysteryBox {</div><div>&nbsp; &nbsp; private double x0, x1, x2;</div><div>&nbsp; &nbsp; private int y0, y1;</div><div>&nbsp; &nbsp; private long z0, z1, z2, z3;</div><div>&nbsp; &nbsp; private boolean[] a = new boolean[72];</div><div><br /></div><div>&nbsp; &nbsp; ...</div><div>}</div><div><br /></div><div>Using the 64-bit memory cost model from lecture, how many bytes does each object of type MysteryBox use?</div>	<div>The correct answer is:184</div><div><br /></div><div>public class MysteryBox { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // &nbsp; 16 (object overhead)</div><div>&nbsp; &nbsp; private double x0, x1, x2; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// &nbsp; 24 (3 double)</div><div>&nbsp; &nbsp; private int y0, y1; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // &nbsp; &nbsp;8 (2 int)</div><div>&nbsp; &nbsp; private long z0, z1, z2, z3; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// &nbsp; 32 (4 long)</div><div>&nbsp; &nbsp; private boolean[] a = new boolean[72]; &nbsp; &nbsp;// &nbsp; &nbsp;8 (reference to array)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // &nbsp; 96 (boolean array of size 72)</div><div>&nbsp; &nbsp; ... &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 (padding)</div><div>} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;----</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 184</div>
